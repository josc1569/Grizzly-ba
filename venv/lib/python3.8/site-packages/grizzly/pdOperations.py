from enum import Enum

import duckdb
import grizzly.dataframes.frame
import pandas as pd
import pyarrow


class pandasOperations(Enum):


    def __assign__(self, **kwargs):
        '''
        Must be called with a lambda function, it does not work with directly referencing an existing Series or sequence
        https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.assign.html#pandas.DataFrame.assign
        '''
        return self.assign(**kwargs)

    def __compare__(self, **kwargs):
        '''
        https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.compare.html#pandas.DataFrame.compare
        '''
        if isinstance(kwargs['other'],grizzly.dataframes.frame.DataFrame):
            other = kwargs['other'].sql_to_dataframe()
        else:
            other = kwargs['other']

        align_axis = 1
        keep_shape = False
        keep_equal = False
        if 'align_axis' in kwargs.keys(): align_axis = kwargs['align_axis']
        if 'keep_shape' in kwargs.keys(): keep_shape = kwargs['keep_shape']
        if 'keep_equal' in kwargs.keys(): keep_equal = kwargs['keep_equal']
        res = self.compare(other=other, align_axis=align_axis, keep_shape=keep_shape, keep_equal=keep_equal)
        return res

    def __join__(self, **kwargs):
        '''
        https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.join.html#pandas.DataFrame.join
        '''
        if isinstance(kwargs['other'], grizzly.dataframes.frame.DataFrame):
            other = kwargs['other'].sql_to_dataframe()
        else:
            other = kwargs['other']

        on = None
        how = 'left'
        lsuffic = ''
        rsuffix = ''
        sort = False
        if 'on' in kwargs.keys(): on = kwargs['on']
        if 'how' in kwargs.keys(): how = kwargs['how']
        if 'lsuffic' in kwargs.keys(): lsuffic = kwargs['lsuffic']
        if 'rsuffix' in kwargs.keys(): rsuffix = kwargs['rsuffix']
        if 'sort' in kwargs.keys(): sort = kwargs['sort']
        res = self.join(other=other, how=how, lsuffic=lsuffic, rsuffix=rsuffix, sort=sort)
        return res

    def __merge__(self, **kwargs):
        '''
        https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.merge.html#pandas.DataFrame.merge
        '''
        if isinstance(kwargs['right'],grizzly.dataframes.frame.DataFrame):
            right = kwargs['right'].sql_to_dataframe()
        else:
            right = kwargs['right']

        how = 'inner'
        on = None
        left_on = None
        right_on = None
        left_index = False
        right_index = False
        sort = False
        suffixes = ('_x', '_y')
        copy = True
        indicator = False
        validate = None
        if 'how' in kwargs.keys(): how = kwargs['how']
        if 'on' in kwargs.keys(): on = kwargs['on']
        if 'left_on' in kwargs.keys(): left_on = kwargs['left_on']
        if 'right_on' in kwargs.keys(): right_on = kwargs['right_on']
        if 'left_index' in kwargs.keys(): left_index = kwargs['left_index']
        if 'right_index' in kwargs.keys(): right_index = kwargs['right_index']
        if 'sort' in kwargs.keys(): sort = kwargs['sort']
        if 'suffixes' in kwargs.keys(): suffixes = kwargs['suffixes']
        if 'copy' in kwargs.keys(): copy = kwargs['copy']
        if 'indicator' in kwargs.keys(): indicator = kwargs['indicator']
        if 'validate' in kwargs.keys(): validate = kwargs['validate']
        res = self.merge(right=right, how=how, on=on, left_on=left_on, right_on=right_on, left_index=left_index, right_index=right_index, sort=sort, suffixes=suffixes, copy=copy, indicator=indicator, validate=validate)
        return res

    def __update__(self, **kwargs):
        '''
        https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.update.html#pandas.DataFrame.update
        '''
        if isinstance(kwargs['other'], grizzly.dataframes.frame.DataFrame):
            other = kwargs['other'].sql_to_dataframe()
        else:
            other = kwargs['other']

        join = 'left'
        overwrite = True
        filter_func = None
        error = 'ignore'
        if 'join' in kwargs.keys(): join = kwargs['join']
        if 'overwrite' in kwargs.keys(): overwrite = kwargs['overwrite']
        if 'filter_func' in kwargs.keys(): filter_func = kwargs['filter_func']
        if 'error' in kwargs.keys(): error = kwargs['error']
        res = self.update(other=other, join=join, overwrite=overwrite, filter_func=filter_func, error=error)
        return res

    def __call__(self, *args, **kwargs):
        return self

    def __abs__(self, **kwargs):
        res = self.abs()
        return res

    def __all__(self, **kwargs):
        axis = 0
        bool_only = None
        skipna = True
        level = None
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'bool_only' in kwargs.keys(): bool_only = kwargs['bool_only']
        if 'skipna' in kwargs.keys(): skipna = kwargs['skipna']
        if 'level' in kwargs.keys(): level = kwargs['level']
        res = self.all(axis=axis, bool_only=bool_only, skipna=skipna, level=level)
        return res

    def __any__(self, **kwargs):
        axis = 0
        bool_only = None
        skipna = True
        level = None
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'bool_only' in kwargs.keys(): bool_only = kwargs['bool_only']
        if 'skipna' in kwargs.keys(): skipna = kwargs['skipna']
        if 'level' in kwargs.keys(): level = kwargs['level']
        res = self.any(axis=axis, bool_only=bool_only, skipna=skipna, level=level)
        return res

    def __clip__(self, **kwargs):
        lower = None
        upper = None
        axis = 0
        inplace = False
        if 'lower' in kwargs.keys(): lower = kwargs['lower']
        if 'upper' in kwargs.keys(): upper = kwargs['upper']
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'inplace' in kwargs.keys(): inplace = kwargs['inplace']
        res = self.clip(lower=lower, upper=upper, axis=axis, inplace=inplace)
        return res

    def __corr__(self, **kwargs):
        method = 'pearson'
        min_periods = 1
        if 'method' in kwargs.keys(): method = kwargs['method']
        if 'min_periods' in kwargs.keys(): min_periods = kwargs['min_periods']
        res = self.corr(method=method, min_periods=min_periods)
        return res
    def __corrwith__(self, **kwargs):
        axis = 0
        drop = False
        method = 'pearson'
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'drop' in kwargs.keys(): drop = kwargs['drop']
        if 'method' in kwargs.keys(): method = kwargs['method']
        res = self.corrwith(other=kwargs['other'], axis=axis, drop=drop, method=method)
        return res

    def __count__(self, **kwargs):
        axis = 0
        level = None
        numeric_only = False
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'level' in kwargs.keys(): level = kwargs['level']
        if 'numeric_only' in kwargs.keys(): numeric_only = kwargs['numeric_only']
        res = self.count(axis=axis, level=level, numeric_only=numeric_only)
        return res

    def __cov__(self, **kwargs):
        min_periods = None
        ddof = 1
        if 'min_periods' in kwargs.keys(): min_periods = kwargs['min_periods']
        if 'ddof' in kwargs.keys(): ddof = kwargs['ddof']
        res = self.cov(min_periods=min_periods, ddof=ddof)
        return res

    def __cummax__(self, **kwargs):
        axis = 0
        skipna = True
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'skipna' in kwargs.keys(): skipna = kwargs['skipna']
        res = self.cummax(axis=axis, skipna=skipna)
        return res

    def __cummin__(self, **kwargs):
        axis = 0
        skipna = True
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'skipna' in kwargs.keys(): skipna = kwargs['skipna']
        res = self.cummin(axis=axis, skipna=skipna)
        return res

    def __cumprod__(self, **kwargs):
        axis = None
        skipna = False
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'skipna' in kwargs.keys(): skipna = kwargs['skipna']
        res = self.cumprod(axis=axis, skipna=skipna)
        return res

    def __cumsum__(self, **kwargs):
        axis = None
        skipna = True
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'skipna' in kwargs.keys(): skipna = kwargs['skipna']
        res = self.cumsum(axis=axis, skipna=skipna)
        return res

    def __describe__(self, **kwargs):
        percentiles = None
        include = None
        exclude = None
        datetime_is_numeric = False
        if 'percentiles' in kwargs.keys(): percentiles = kwargs['percentiles']
        if 'include' in kwargs.keys(): include = kwargs['include']
        if 'exclude' in kwargs.keys(): exclude = kwargs['exclude']
        if 'datetime_is_numeric' in kwargs.keys(): datetime_is_numeric = kwargs['datetime_is_numeric']
        res = self.describe(percentiles=percentiles, include=include, exclude=exclude, datetime_is_numeric=datetime_is_numeric)
        return res

    def __diff__(self, **kwargs):
        periods = 1
        axis = 0
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'periods' in kwargs.keys(): periods = kwargs['periods']
        res = self.diff(axis=axis, periods=periods)
        return res

    def __eval__(self, **kwargs):
        inplace = False
        if 'inplace' in kwargs.keys(): inplace = kwargs['inplace']
        res = self.eval(expr=kwargs['expr'], inplace=inplace)
        return res

    def __kurt__(self, **kwargs):
        skipna = True
        level = None
        numeric_only = None
        if 'skipna' in kwargs.keys(): skipna = kwargs['skipna']
        if 'level' in kwargs.keys(): level = kwargs['level']
        if 'numeric_only' in kwargs.keys(): numeric_only = kwargs['numeric_only']
        res = self.kurt(axis=kwargs['axis'], skipna=skipna, level=level, numeric_only=numeric_only)
        return res

    def __kurtosis__(self, **kwargs):
        skipna = True
        level = None
        numeric_only = None
        if 'skipna' in kwargs.keys(): skipna = kwargs['skipna']
        if 'level' in kwargs.keys(): level = kwargs['level']
        if 'numeric_only' in kwargs.keys(): numeric_only = kwargs['numeric_only']
        res = self.kurtosis(axis=kwargs['axis'], skipna=skipna, level=level, numeric_only=numeric_only)
        return res

    def __mad__(self, **kwargs):
        axis = None
        skipna = True
        level = None
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'skipna' in kwargs.keys(): skipna = kwargs['skipna']
        if 'level' in kwargs.keys(): level = kwargs['level']
        res = self.mad(axis=axis, skipna=skipna, level=level)
        return res

    def __max__(self, **kwargs):
        axis = NoDefault.no_default
        skipna = True
        level = None
        numeric_only = None
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'skipna' in kwargs.keys(): skipna = kwargs['skipna']
        if 'level' in kwargs.keys(): level = kwargs['level']
        if 'numeric_only' in kwargs.keys(): numeric_only = kwargs['numeric_only']
        res = self.max(axis=axis, skipna=skipna, level=level, numeric_only=numeric_only)
        return res

    def __mean__(self, **kwargs):
        axis = NoDefault.no_default
        skipna = True
        level = None
        numeric_only = None
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'skipna' in kwargs.keys(): skipna = kwargs['skipna']
        if 'level' in kwargs.keys(): level = kwargs['level']
        if 'numeric_only' in kwargs.keys(): numeric_only = kwargs['numeric_only']
        res = self.mean(axis=axis, skipna=skipna, level=level, numeric_only=numeric_only)
        return res

    def __median__(self, **kwargs):
        axis = NoDefault.no_default
        skipna = True
        level = None
        numeric_only = None
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'skipna' in kwargs.keys(): skipna = kwargs['skipna']
        if 'level' in kwargs.keys(): level = kwargs['level']
        if 'numeric_only' in kwargs.keys(): numeric_only = kwargs['numeric_only']
        res = self.median(axis=axis, skipna=skipna, level=level, numeric_only=numeric_only)
        return res

    def __min__(self, **kwargs):
        axis = NoDefault.no_default
        skipna = True
        level = None
        numeric_only = None
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'skipna' in kwargs.keys(): skipna = kwargs['skipna']
        if 'level' in kwargs.keys(): level = kwargs['level']
        if 'numeric_only' in kwargs.keys(): numeric_only = kwargs['numeric_only']
        res = self.min(axis=axis, skipna=skipna, level=level, numeric_only=numeric_only)
        return res

    def __mode__(self, **kwargs):
        axis = 0
        numeric_only = False
        dropna = True
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'numeric_only' in kwargs.keys(): numeric_only = kwargs['numeric_only']
        if 'dropna' in kwargs.keys(): dropna = kwargs['dropna']
        res = self.mode(axis=axis, numeric_only=numeric_only, dropna=dropna)
        return res

    def __pct_change__(self, **kwargs):
        periods = 1
        fill_method = 'pad'
        limit = None
        freq = None
        if 'periods' in kwargs.keys(): periods = kwargs['periods']
        if 'fill_method' in kwargs.keys(): fill_method = kwargs['fill_method']
        if 'limit' in kwargs.keys(): limit = kwargs['limit']
        if 'freq' in kwargs.keys(): freq = kwargs['freq']
        res = self.pct_change(periods=periods, fill_method=fill_method, limit=limit, freq=freq)
        return res

    def __prod__(self, **kwargs):
        axis = None
        skipna = True
        level = None
        numeric_only = None
        min_count = 0
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'skipna' in kwargs.keys(): skipna = kwargs['skipna']
        if 'level' in kwargs.keys(): level = kwargs['level']
        if 'numeric_only' in kwargs.keys(): numeric_only = kwargs['numeric_only']
        if 'min_count' in kwargs.keys(): min_count = kwargs['min_count']
        res = self.prod(axis=axis, skipna=skipna, level=level, numeric_only=numeric_only, min_count=min_count)
        return res

    def __product__(self, **kwargs):
        axis = None
        skipna = True
        level = None
        numeric_only = None
        min_count = 0
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'skipna' in kwargs.keys(): skipna = kwargs['skipna']
        if 'level' in kwargs.keys(): level = kwargs['level']
        if 'numeric_only' in kwargs.keys(): numeric_only = kwargs['numeric_only']
        if 'min_count' in kwargs.keys(): min_count = kwargs['min_count']
        res = self.product(axis=axis, skipna=skipna, level=level, numeric_only=numeric_only, min_count=min_count)
        return res

    def __quantile__(self, **kwargs):
        q = 0.5
        axis = 0
        numeric_only = True
        interpolation = 'linear'
        if 'q' in kwargs.keys(): q = kwargs['q']
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'numeric_only' in kwargs.keys(): numeric_only = kwargs['numeric_only']
        if 'interpolation' in kwargs.keys(): interpolation = kwargs['interpolation']
        res = self.quantile(q=q, axis=axis, numeric_only=numeric_only, interpolation=interpolation)
        return res

    def __rank__(self, **kwargs):
        axis = 0
        method = 'average'
        numeric_only = NoDefault.no_default
        na_option = 'keep'
        ascending = True
        pct = False
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'method' in kwargs.keys(): method = kwargs['method']
        if 'numeric_only' in kwargs.keys(): numeric_only = kwargs['numeric_only']
        if 'na_option' in kwargs.keys(): na_option = kwargs['na_option']
        if 'ascending' in kwargs.keys(): ascending = kwargs['ascending']
        if 'pct' in kwargs.keys(): pct = kwargs['pct']
        res = self.rank(axis=axis, method=method, numeric_only=numeric_only, na_option=na_option, ascending=ascending, pct=pct)
        return res

    def __round__(self, **kwargs):
        decimals = 0
        if 'decimals' in kwargs.keys(): decimals = kwargs['decimals']
        res = self.round(decimals=decimals)
        return res

    def __sem__(self, **kwargs):
        axis = None
        skipna = True
        level = None
        ddof = 1
        numeric_only = None
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'skipna' in kwargs.keys(): skipna = kwargs['skipna']
        if 'level' in kwargs.keys(): level = kwargs['level']
        if 'ddof' in kwargs.keys(): ddof = kwargs['ddof']
        if 'numeric_only' in kwargs.keys(): numeric_only = kwargs['numeric_only']
        res = self.sem(axis=axis, skipna=skipna, level=level, ddof=ddof, numeric_only=numeric_only)
        return res

    def __skew__(self, **kwargs):
        axis = NoDefault.no_default
        skipna = True
        level = None
        numeric_only = None
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'skipna' in kwargs.keys(): skipna = kwargs['skipna']
        if 'level' in kwargs.keys(): level = kwargs['level']
        if 'numeric_only' in kwargs.keys(): numeric_only = kwargs['numeric_only']
        res = self.skew(axis=axis, skipna=skipna, level=level, numeric_only=numeric_only)
        return res

    def __sum__(self, **kwargs):
        axis = None
        skipna = True
        level = None
        numeric_only = None
        min_count = 0
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'skipna' in kwargs.keys(): skipna = kwargs['skipna']
        if 'level' in kwargs.keys(): level = kwargs['level']
        if 'numeric_only' in kwargs.keys(): numeric_only = kwargs['numeric_only']
        if 'min_count' in kwargs.keys(): min_count = kwargs['min_count']
        res = self.sum(axis=axis, skipna=skipna, level=level, numeric_only=numeric_only, min_count=min_count)
        return res

    def __std__(self, **kwargs):
        axis = None
        skipna = True
        level = None
        ddof = 1
        numeric_only = None
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'skipna' in kwargs.keys(): skipna = kwargs['skipna']
        if 'level' in kwargs.keys(): level = kwargs['level']
        if 'ddof' in kwargs.keys(): ddof = kwargs['ddof']
        if 'numeric_only' in kwargs.keys(): numeric_only = kwargs['numeric_only']
        res = self.std(axis=axis, skipna=skipna, level=level, ddof=ddof, numeric_only=numeric_only)
        return res

    def __var__(self, **kwargs):
        axis = None
        skipna = True
        level = None
        ddof = 1
        numeric_only = None
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'skipna' in kwargs.keys(): skipna = kwargs['skipna']
        if 'level' in kwargs.keys(): level = kwargs['level']
        if 'ddof' in kwargs.keys(): ddof = kwargs['ddof']
        if 'numeric_only' in kwargs.keys(): numeric_only = kwargs['numeric_only']
        res = self.var(axis=axis, skipna=skipna, level=level, ddof=ddof, numeric_only=numeric_only)
        return res

    def __nunique__(self, **kwargs):
        axis = 0
        dropna = True
        if 'axis' in kwargs.keys(): axis = kwargs['axis']
        if 'dropna' in kwargs.keys(): dropna = kwargs['dropna']
        res = self.nunique(axis=axis, dropna=dropna)
        return res

    def __value_counts__(self, **kwargs):
        subset = None
        normalize = False
        sort = True
        ascending = False
        dropna = True
        if 'subset' in kwargs.keys(): subset = kwargs['subset']
        if 'normalize' in kwargs.keys(): normalize = kwargs['normalize']
        if 'sort' in kwargs.keys(): sort = kwargs['sort']
        if 'ascending' in kwargs.keys(): ascending = kwargs['ascending']
        if 'dropna' in kwargs.keys(): dropna = kwargs['dropna']
        res = self.value_counts(subset=subset, normalize=normalize, sort=sort, ascending=ascending, dropna=dropna)
        return res

class DuckDBOperations(Enum):
    import duckdb

    def __merge__(self, **kwargs):
        con = duckdb.connect()
        pdf1 = self.sql_to_dataframe()
        rel1 = con.from_df(pdf1)

        if 'objs' in kwargs.keys():
            if isinstance(kwargs['objs'], grizzly.dataframes.frame.DataFrame):
                #If this given objects is a grizzly dataframe convert it to duckdb relation
                pdf2 = kwargs['objs'].sql_to_dataframe()
                rel2 = con.from_df(pdf2)
            else:
                rel2 = kwargs['objs']

        res = con.execute("SELECT * FROM pdf1, pdf2 WHERE pdf1.globaleventid = pdf2.globaleventid").fetchdf()
        return res

    def __print__(self, **kwargs):
        print(self)
        return self


class ApacheArrowOperations(Enum):
    import pyarrow

    def __concat_tables__(self, **kwargs):
        if isinstance(kwargs['tables'], grizzly.dataframes.frame.DataFrame):
            pdf = kwargs['tables'].sql_to_dataframe()
            tables = pyarrow.Table.from_pandas(pdf)
            print(type(self),type(tables))
        else:
            tables = kwargs['tables']
        tables = [self, tables]
        promote = False
        memory_pool = None
        res = pyarrow.concat_tables(tables=tables, promote=promote, memory_pool=memory_pool)
        return res

    def __group_by__(self, **kwargs):
        keys = kwargs['keys']
        res = self.group_by('key')
        return res

    def __aggregate__(self, **kwargs):
        aggregations = kwargs['aggregations']
        res = self.aggregate(aggregations)
        return res
